{-# LANGUAGE RecursiveDo #-}

module Data.SF.Switching where

import Control.Monad (when)
import Data.IORef
import Data.SF.Core
import Data.Vector qualified as V

-- | 'caseOf' is a powerful combinator to implement switching behavior. It is similar to case expressions, but for signal functions.
--
-- The first argument determines some @c@. The second argument takes the @c@ and decides which signal function should be used.
-- The signal functions generated by the second function keep their state across executions, i.e. when they get selected multiple times,
-- they keep their state.
--
-- Beware that this function should not be used when @c@ has many (~dozens) cases, since the setup phase will be run for each case.
caseOf :: forall c r a b. (Bounded c, Enum c) => SF r a c -> (c -> SF r a b) -> SF r a b
caseOf decider makeSF = SF $ \fin r -> do
  when (fromEnum (maxBound :: c) - fromEnum (minBound :: c) > 100) $
    fail "You probably do not want to use `caseSF` with so many cases. Use `manyCaseSF` if you really want to."
  unSF (manyCaseSF decider makeSF) fin r
{-# INLINE caseOf #-}

-- | Same as `caseOf` but will not error when you have a @c@ with many cases.
manyCaseSF :: (Bounded c, Enum c) => SF r a c -> (c -> SF r a b) -> SF r a b
manyCaseSF (SF makeDecider) makeSF = SF $ \fin r -> do
  decide <- makeDecider fin r
  sfs <- V.fromList <$> traverse (\c -> unSF (makeSF c) fin r) [minBound .. maxBound]
  pure $ \a -> do
    c <- decide a
    let step = sfs V.! fromEnum c
    step a
{-# INLINE manyCaseSF #-}

-- | Switch out a signal function with another when you produce a @Just c@ value.
-- The next signal function will become active in the next iteration.
switch :: SF r a (b, Maybe c) -> (c -> SF r a b) -> SF r a b
switch sf kont = SF $ \fin r -> mdo
  newFin <- newFinalizer
  f <- unSF sf newFin r

  stepRef <- newIORef $ \a -> do
    (b, maybeC) <- f a
    case maybeC of
      Nothing -> pure b
      Just c -> do
        newStep <- unSF (kont c) fin r
        writeIORef stepRef newStep
        runFinalizer newFin
        pure b

  readIORef stepRef
