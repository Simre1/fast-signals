module Data.SF.Combinators where

import Control.Arrow (Arrow (..), (>>>))
import Control.Monad (when)
import Data.Coerce (coerce)
import Data.IORef
import Data.SF.Core
import Data.Vector qualified as V

-- | Duplicating the input may be useful for various other arrow combinators.
dup :: SF r a (a, a)
dup = arr (\a -> (a, a))
{-# INLINE dup #-}

-- | Same as `arr` but for functions with two arguments.
arr2 :: (a -> b -> c) -> SF r (a, b) c
arr2 f = arr (uncurry f)
{-# INLINE arr2 #-}

-- | Same as `id` but for signal functions
identity :: SF r a a
identity = arr id
{-# INLINE identity #-}

-- | Same as `const` but for signal functions
constant :: b -> SF r a b
constant = pure
{-# INLINE constant #-}

-- | 'caseOf' is a powerful combinator to implement switching behavior. It is similar to case expressions, but for signal functions.
-- 
-- The first argument determines some `c`. The second argument takes the `c` and decides which signal function should be used. 
-- The signal functions generated by the second function keep their state across executions, i.e. when they get selected multiple times,
-- they keep their state. 
--
-- Beware that this function should not be used when `c` has many (~dozens) cases, since the setup phase will be run for each case. 
caseOf :: forall c r a b. (Bounded c, Enum c) => SF r a c -> (c -> SF r a b) -> SF r a b
caseOf decider makeSF = SF $ \r -> do
  when (fromEnum (maxBound :: c) - fromEnum (minBound :: c) > 100) $
    fail "You probably do not want to use `caseSF` with so many cases. Use `manyCaseSF` if you really want to."
  coerce (manyCaseSF decider makeSF) r
{-# INLINE caseOf #-}

-- | Same as `caseOf` but will not error when you have a `c` with many cases.
manyCaseSF :: (Bounded c, Enum c) => SF r a c -> (c -> SF r a b) -> SF r a b
manyCaseSF (SF makeDecider) makeSF = SF $ \r -> do
  decide <- makeDecider r
  sfs <- V.fromList <$> traverse (($ r) . coerce . makeSF) [minBound .. maxBound]
  pure $ \a -> do
    c <- decide a
    let step = sfs V.! fromEnum c
    step a
{-# INLINE manyCaseSF #-}

-- | Feeds the output state back as input. The state `s` is strict.
feedback :: s -> SF r (a, s) (b, s) -> SF r a b
feedback !initial (SF sf) = SF $ \r -> do
  f <- sf r
  stateRef <- newIORef initial
  pure $ \a -> do
    !s <- readIORef stateRef
    (b, !s') <- f (a, s)
    writeIORef stateRef s'
    pure b
{-# INLINE feedback #-}

-- | Feeds the output state back as input. The state `s` is lazy, so beware space leaks.
lazyFeedback :: s -> SF r (a, s) (b, s) -> SF r a b
lazyFeedback initial (SF sf) = SF $ \r -> do
  f <- sf r
  stateRef <- newIORef initial
  pure $ \a -> do
    s <- readIORef stateRef
    (b, s') <- f (a, s)
    writeIORef stateRef s'
    pure b
{-# INLINE lazyFeedback #-}

-- | Scan along time. The first function will be run each execution with the input `a`, produce the output `b` and reuse `b` as state for the next iteration. 
scan :: (b -> a -> b) -> b -> SF r a b
scan f initial = feedback initial (arr2 (flip f) >>> dup)
{-# INLINE scan #-}
