{-# LANGUAGE RecursiveDo #-}

module Data.Signal.Switching where

import Control.Monad (when)
import Data.IORef
import Data.Signal.Core
import Data.Vector qualified as V

-- | 'caseOf' is a powerful combinator to implement switching behavior. It is similar to case expressions, but for signal functions.
--
-- The first argument determines some @c@. The second argument takes the @c@ and decides which signal function should be used.
-- The signal functions generated by the second function keep their state across executions, i.e. when they get selected multiple times,
-- they keep their state.
--
-- Beware that this function should not be used when @c@ has many (~dozens) cases, since the setup phase will be run for each case.
caseOf :: forall c r a b. (Bounded c, Enum c) => Signal r a c -> (c -> Signal r a b) -> Signal r a b
caseOf decider makeSignal = Signal $ \fin r -> do
  when (fromEnum (maxBound :: c) - fromEnum (minBound :: c) > 100) $
    fail "You probably do not want to use `caseSignal` with so many cases. Use `manyCaseSignal` if you really want to."
  unSignal (manyCaseSignal decider makeSignal) fin r
{-# INLINE caseOf #-}

-- | Same as `caseOf` but will not error when you have a @c@ with many cases.
manyCaseSignal :: (Bounded c, Enum c) => Signal r a c -> (c -> Signal r a b) -> Signal r a b
manyCaseSignal (Signal makeDecider) makeSignal = Signal $ \fin r -> do
  decide <- makeDecider fin r
  signals <- V.fromList <$> traverse (\c -> unSignal (makeSignal c) fin r) [minBound .. maxBound]
  pure $ \a -> do
    c <- decide a
    let step = signals V.! fromEnum c
    step a
{-# INLINE manyCaseSignal #-}

-- | Switch out a signal function with another when you produce a @Just c@ value.
-- The next signal function will become active in the next iteration.
switch :: Signal r a (b, Maybe c) -> (c -> Signal r a b) -> Signal r a b
switch signal kont = Signal $ \fin r -> mdo
  newFin <- newFinalizer
  f <- unSignal signal newFin r

  stepRef <- newIORef $ \a -> do
    (b, maybeC) <- f a
    case maybeC of
      Nothing -> pure b
      Just c -> do
        newStep <- unSignal (kont c) fin r
        writeIORef stepRef newStep
        runFinalizer newFin
        pure b

  readIORef stepRef
